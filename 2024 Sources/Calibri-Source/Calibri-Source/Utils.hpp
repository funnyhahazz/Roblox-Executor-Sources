#include <iostream>
#include <Windows.h>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <string>
#include <thread>
#include <vector>
#include <queue>
#include <map>

#include "XorStr.hpp"

#include <ShlObj.h>
#include <Wininet.h>
#include <TlHelp32.h>
#include <queue>

#pragma comment(lib, "wininet.lib")

#include "Compressor/include/xxhash.h"
#include "Compressor/include/zstd.h"


namespace Utils
{
	static std::string init_script = "CmdldGdlbnYoKS5sb2FkZmlsZSA9IG5ld2NjbG9zdXJlKGZ1bmN0aW9uKGZpbGVuYW1lKQpyZXR1cm4gbG9hZHN0cmluZyhyZWFkZmlsZShmaWxlbmFtZSkpCmVuZCkKCmxvY2FsIGZ1bmN0aW9uIHJlZ2lzdGVyKGksIHYpCiAgICBnZXRnZW52KClbaV0gPSB2CiAgICByZXR1cm4gdgplbmQKCmlmIG5vdCBob29rbWV0YW1ldGhvZCB0aGVuCiAgICByZWdpc3RlcignaG9va21ldGFtZXRob2QnLCBuZXdjY2xvc3VyZShmdW5jdGlvbihvYmosIG1ldGhvZCwgZnVuYykKICAgICAgICBhc3NlcnQodHlwZShvYmopID09ICd0YWJsZScgb3IgdHlwZW9mKG9iaikgPT0gJ0luc3RhbmNlJywgJ0luc3RhbmNlIG9yIHVzZXJkYXRhIGV4cGVjdGVkIGFzIGFyZ3VtZW50ICMxJykKICAgICAgICBhc3NlcnQodHlwZShtZXRob2QpID09ICdzdHJpbmcnLCAnc3RyaW5nIGV4cGVjdGVkIGFzIGFyZ3VtZW50ICMyJykKICAgICAgICBhc3NlcnQodHlwZShmdW5jKSA9PSAnZnVuY3Rpb24nLCAnZnVuY3Rpb24gZXhwZWN0ZWQgYXMgYXJndW1lbnQgIzMnKQogICAgCiAgICAgICAgbG9jYWwgbXQgPSBnZXRyYXdtZXRhdGFibGUob2JqKQogICAgICAgIGFzc2VydCh0eXBlKG10KSA9PSAndGFibGUnLCAnb2JqZWN0IGdpdmVuIGluIGFyZ3VtZW50ICMxIGhhcyBubyBtZXRhdGFibGUvaXQgaXMgd3JvbmcnKQogICAgCiAgICAgICAgbG9jYWwgZnVuY2Zyb20gPSByYXdnZXQobXQsIG1ldGhvZCkKICAgICAgICBhc3NlcnQodHlwZShmdW5jZnJvbSkgPT0gJ2Z1bmN0aW9uJywgJ2ludmFsaWQgbWV0aG9kIHByb3ZpZGVkIGluIGFyZ3VtZW50ICMyJykKICAgICAgICAKICAgICAgICBpZiAoaXNjY2xvc3VyZShmdW5jZnJvbSkgYW5kIG5vdCBpc2NjbG9zdXJlKGZ1bmMpKSB0aGVuCiAgICAgICAgICAgIGZ1bmMgPSBuZXdjY2xvc3VyZShmdW5jKQogICAgICAgIGVuZAogICAgCiAgICAgICAgbG9jYWwgb2xkCiAgICAgICAgb2xkID0gaG9va2Z1bmN0aW9uKGZ1bmNmcm9tLCBmdW5jKQogICAgCiAgICAgICAgcmV0dXJuIG9sZAogICAgZW5kKSkgICAgCmVuZAoKaWYgbm90IFdlYlNvY2tldCB0aGVuCiAgICBsb2NhbCBXZWJTb2NrZXQgPSB7fQoKICAgIFdlYlNvY2tldC5jb25uZWN0ID0gbmV3Y2Nsb3N1cmUoZnVuY3Rpb24oKQogICAgICAgIHJldHVybiB7ICAgICAgICAgICAgCiAgICAgICAgICAgIFNlbmQgPSBuZXdjY2xvc3VyZShmdW5jdGlvbigpIGVuZCksCiAgICAgICAgICAgIENsb3NlID0gbmV3Y2Nsb3N1cmUoZnVuY3Rpb24oKSBlbmQpLAogICAgICAgICAgICBPbk1lc3NhZ2UgPSB7IENvbm5lY3QgPSBuZXdjY2xvc3VyZShmdW5jdGlvbigpIGVuZCkgfSwKICAgICAgICAgICAgT25DbG9zZSA9IHsgQ29ubmVjdCA9IG5ld2NjbG9zdXJlKGZ1bmN0aW9uKCkgZW5kKSB9CiAgICAgICAgfQogICAgZW5kKQoKICAgIHJlZ2lzdGVyKCdXZWJTb2NrZXQnLCBXZWJTb2NrZXQpCmVuZAoKZG8KICAgIGxvY2FsIHJlYWxfc2V0c2NyaXB0YWJsZSA9IGNsb25lZnVuY3Rpb24oc2V0c2NyaXB0YWJsZSkKICAgIGxvY2FsIHJlYWxfaXNzY3JpcHRhYmxlID0gY2xvbmVmdW5jdGlvbihpc3NjcmlwdGFibGUpCgogICAgbG9jYWwgc2NyaXB0YWJsZWQgPSB7fQogICAgbG9jYWwgc2NyaXB0YWJsZWRQcm9wZXJ0aWVzID0ge30KCiAgICBsb2NhbCBub3R2YWxpZCA9ICclcyBpcyBub3QgYSB2YWxpZCBtZW1iZXIgb2YgJXMgIiVzIicgCgogICAgcmVnaXN0ZXIoJ2lzc2NyaXB0YWJsZScsIG5ld2NjbG9zdXJlKGZ1bmN0aW9uKHNlbGYsIGkpCiAgICAgICAgYXNzZXJ0KHR5cGVvZihzZWxmKSA9PSAnSW5zdGFuY2UnLCAnSW5zdGFuY2UgZXhwZWN0ZWQgYXMgYXJndW1lbnQgIzEnKQogICAgICAgIGFzc2VydCh0eXBlb2YoaSkgPT0gJ3N0cmluZycsICdzdHJpbmcgZXhwZWN0ZWQgYXMgYXJndW1lbnQgIzInKQogICAgICAgIAogICAgICAgIGlmIG5vdCBzY3JpcHRhYmxlZFByb3BlcnRpZXNbaV0gdGhlbgogICAgICAgICAgICByZXR1cm4gcmVhbF9pc3NjcmlwdGFibGUoc2VsZiwgaSkKICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiBzY3JpcHRhYmxlZFtzZWxmXSB+PSBuaWwgYW5kIHNjcmlwdGFibGVkW3NlbGZdW2ldID09IHRydWUKICAgICAgICBlbmQKICAgIGVuZCkpCgogICAgcmVnaXN0ZXIoJ3NldHNjcmlwdGFibGUnLCBuZXdjY2xvc3VyZShmdW5jdGlvbihzZWxmLCBpLCB2KQogICAgICAgIGFzc2VydCh0eXBlb2Yoc2VsZikgPT0gJ0luc3RhbmNlJywgJ0luc3RhbmNlIGV4cGVjdGVkIGFzIGFyZ3VtZW50ICMxJykKICAgICAgICBhc3NlcnQodHlwZW9mKGkpID09ICdzdHJpbmcnLCAnc3RyaW5nIGV4cGVjdGVkIGFzIGFyZ3VtZW50ICMyJykKICAgICAgICBhc3NlcnQodHlwZW9mKHYpID09ICdib29sZWFuJywgJ2Jvb2xlYW4gZXhwZWN0ZWQgYXMgYXJndW1lbnQgIzMnKQogICAgICAgIAogICAgICAgIGxvY2FsIHdhc1NjcmlwdGFibGUgPSBpc3NjcmlwdGFibGUoc2VsZiwgaSkKCiAgICAgICAgaWYgdiA9PSBmYWxzZSB0aGVuCiAgICAgICAgICAgIGlmIHNjcmlwdGFibGVkW3NlbGZdIHRoZW4KICAgICAgICAgICAgICAgIHNjcmlwdGFibGVkW3NlbGZdW2ldID0gbmlsCiAgICAgICAgICAgIGVuZAogICAgICAgIGVsc2VpZiB2ID09IHRydWUgdGhlbgogICAgICAgICAgICBpZiBub3Qgc2NyaXB0YWJsZWRbc2VsZl0gdGhlbgogICAgICAgICAgICAgICAgc2NyaXB0YWJsZWRbc2VsZl0gPSB7fQogICAgICAgICAgICBlbmQKICAgICAgICAgICAgc2NyaXB0YWJsZWRbc2VsZl1baV0gPSB0cnVlCiAgICAgICAgICAgIHJlYWxfc2V0c2NyaXB0YWJsZShzZWxmLCBpLCB0cnVlKQogICAgICAgICAgICBzY3JpcHRhYmxlZFByb3BlcnRpZXNbaV0gPSB0cnVlCiAgICAgICAgZW5kCgogICAgICAgIHJldHVybiB3YXNTY3JpcHRhYmxlCiAgICBlbmQpKQoKICAgIHJlZ2lzdGVyKCdnZXRoaWRkZW5wcm9wZXJ0eScsIG5ld2NjbG9zdXJlKGZ1bmN0aW9uKHNlbGYsIGkpCiAgICAgICAgYXNzZXJ0KHR5cGVvZihzZWxmKSA9PSAnSW5zdGFuY2UnLCAnSW5zdGFuY2UgZXhwZWN0ZWQgYXMgYXJndW1lbnQgIzEnKQogICAgICAgIGFzc2VydCh0eXBlb2YoaSkgPT0gJ3N0cmluZycsICdzdHJpbmcgZXhwZWN0ZWQgYXMgYXJndW1lbnQgIzInKQoKICAgICAgICBsb2NhbCBvbGRzID0gc2V0c2NyaXB0YWJsZShzZWxmLCBpLCB0cnVlKQogICAgICAgIGxvY2FsIHJlcyA9IHNlbGZbaV0KICAgICAgICBpZiBub3Qgb2xkcyB0aGVuCiAgICAgICAgICAgIHNldHNjcmlwdGFibGUoc2VsZiwgaSwgb2xkcykKICAgICAgICBlbmQKICAgICAgICByZXR1cm4gcmVzLCBub3Qgb2xkcwogICAgZW5kKSkKCiAgICByZWdpc3Rlcignc2V0aGlkZGVucHJvcGVydHknLCBuZXdjY2xvc3VyZShmdW5jdGlvbihzZWxmLCBpLCB2KQogICAgICAgIGFzc2VydCh0eXBlb2Yoc2VsZikgPT0gJ0luc3RhbmNlJywgJ0luc3RhbmNlIGV4cGVjdGVkIGFzIGFyZ3VtZW50ICMxJykKICAgICAgICBhc3NlcnQodHlwZW9mKGkpID09ICdzdHJpbmcnLCAnc3RyaW5nIGV4cGVjdGVkIGFzIGFyZ3VtZW50ICMyJykKCiAgICAgICAgbG9jYWwgb2xkcyA9IHNldHNjcmlwdGFibGUoc2VsZiwgaSwgdHJ1ZSkKICAgICAgICBzZWxmW2ldID0gdgogICAgICAgIGlmIG5vdCBvbGRzIHRoZW4KICAgICAgICAgICAgc2V0c2NyaXB0YWJsZShzZWxmLCBpLCBvbGRzKQogICAgICAgIGVuZAoKICAgICAgICByZXR1cm4gbm90IG9sZHMKICAgIGVuZCkpCmVuZAoKZG8KICAgIGxvY2FsIHNhdmVkQ2xvc3VyZXMgPSB7fQoKICAgIHJlZ2lzdGVyKCdnZXRzY3JpcHRjbG9zdXJlJywgbmV3Y2Nsb3N1cmUoZnVuY3Rpb24oc2NyKQogICAgICAgIGFzc2VydCh0eXBlb2Yoc2NyKSA9PSAnSW5zdGFuY2UnIGFuZCAoc2NyLkNsYXNzTmFtZSA9PSAnTG9jYWxTY3JpcHQnIG9yIHNjci5DbGFzc05hbWUgPT0gJ01vZHVsZVNjcmlwdCcpLCAnc2NyaXB0IGV4cGVjdGVkIGFzIGFyZ3VtZW50ICMxJykKICAgICAgICBpZiBzYXZlZENsb3N1cmVzW3Njcl0gdGhlbgogICAgICAgICAgICByZXR1cm4gc2F2ZWRDbG9zdXJlc1tzY3JdCiAgICAgICAgZW5kCiAgICAgICAgZm9yIGksdiBpbiBuZXh0LCBnZXRnYygpIGRvCiAgICAgICAgICAgIGlmIHR5cGUodikgPT0gJ2Z1bmN0aW9uJyB0aGVuCiAgICAgICAgICAgICAgICBsb2NhbCBlbnYgPSBnZXRmZW52KHYpCiAgICAgICAgICAgICAgICBpZiB0eXBlKGVudikgPT0gJ3RhYmxlJyBhbmQgcmF3Z2V0KGVudiwgJ3NjcmlwdCcpID09IHNjciB0aGVuCiAgICAgICAgICAgICAgICAgICAgc2F2ZWRDbG9zdXJlc1tzY3JdID0gdgogICAgICAgICAgICAgICAgICAgIHJldHVybiB2CiAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgZW5kCiAgICAgICAgZW5kCiAgICBlbmQpKQplbmQKCmRvCiAgICBsb2NhbCBDb3JlR3VpID0gZ2FtZTpHZXRTZXJ2aWNlKCdDb3JlR3VpJykKICAgIGxvY2FsIEh0dHBTZXJ2aWNlID0gZ2FtZTpHZXRTZXJ2aWNlKCdIdHRwU2VydmljZScpCgogICAgbG9jYWwgY29tbV9jaGFubmVscyA9IENvcmVHdWk6RmluZEZpcnN0Q2hpbGQoJ2NvbW1fY2hhbm5lbHMnKSBvciBJbnN0YW5jZS5uZXcoJ0ZvbGRlcicsIENvcmVHdWkpCiAgICBpZiBjb21tX2NoYW5uZWxzLk5hbWUgfj0gJ2NvbW1fY2hhbm5lbHMnIHRoZW4KICAgICAgICBjb21tX2NoYW5uZWxzLk5hbWUgPSAnY29tbV9jaGFubmVscycKICAgIGVuZAogICAgcmVnaXN0ZXIoJ2NyZWF0ZV9jb21tX2NoYW5uZWwnLCBuZXdjY2xvc3VyZShmdW5jdGlvbigpCiAgICAgICAgbG9jYWwgaWQgPSBIdHRwU2VydmljZTpHZW5lcmF0ZUdVSUQoKQogICAgICAgIGxvY2FsIGV2ZW50ID0gSW5zdGFuY2UubmV3KCdCaW5kYWJsZUV2ZW50JywgY29tbV9jaGFubmVscykKICAgICAgICBldmVudC5OYW1lID0gaWQKICAgICAgICByZXR1cm4gaWQsIGV2ZW50CiAgICBlbmQpKQoKICAgIHJlZ2lzdGVyKCdnZXRfY29tbV9jaGFubmVsJywgbmV3Y2Nsb3N1cmUoZnVuY3Rpb24oaWQpCiAgICAgICAgYXNzZXJ0KHR5cGUoaWQpID09ICdzdHJpbmcnLCAnc3RyaW5nIGV4cGVjdGVkIGFzIGFyZ3VtZW50ICMxJykKICAgICAgICByZXR1cm4gY29tbV9jaGFubmVsczpGaW5kRmlyc3RDaGlsZChpZCkKICAgIGVuZCkpCmVuZAoKZ2V0Z2VudigpLmdldG1lbnYgPSBnZXRzZW52CgpnZXRnZW52KCkuZ2V0aW5zdGFuY2VzID0gbmV3Y2Nsb3N1cmUoZnVuY3Rpb24oKQogICAgICAgICAgICBsb2NhbCBvYmpzID0ge30KICAgICAgICAgICAgZm9yIGksdiBpbiBuZXh0LCBnZXRyZWcoKSBkbwogICAgICAgICAgICAgICBpZiB0eXBlKHYpPT0ndGFibGUnIHRoZW4KICAgICAgICAgICAgICAgICAgZm9yIG8sYiBpbiBuZXh0LCB2IGRvCiAgICAgICAgICAgICAgICAgICAgICBpZiB0eXBlb2YoYikgPT0gIkluc3RhbmNlIiB0aGVuCiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLmluc2VydChvYmpzLCBiKQogICAgICAgICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgZW5kCiAgICAgICAgIHJldHVybiBvYmpzCiBlbmQpCgoKZ2V0Z2VudigpLmdldG5pbGluc3RhbmNlcyA9IG5ld2NjbG9zdXJlKGZ1bmN0aW9uKCkKICAgIGxvY2FsIG9ianMgPSB7fQoJZm9yIGksdiBpbiBuZXh0LGdldHJlZygpIGRvCgkJaWYgdHlwZSh2KT09InRhYmxlIiB0aGVuCgkJCWZvciBvLGIgaW4gbmV4dCx2IGRvCgkJCQlpZiB0eXBlb2YoYikgPT0gIkluc3RhbmNlIiBhbmQgYi5QYXJlbnQ9PW5pbCB0aGVuCgkJCQkJdGFibGUuaW5zZXJ0KG9ianMsIGIpCgkJCQllbmQKCQkJZW5kCgkJZW5kCgllbmQKCXJldHVybiBvYmpzCmVuZCkKCgpnZXRnZW52KCkuZ2V0X25pbF9pbnN0YW5jZXMgPSBnZXRnZW52KCkuZ2V0bmlsaW5zdGFuY2VzCgpnZXRnZW52KCkudW5sb2NrbW9kdWxlc2NyaXB0ID0gdHJ1ZQoKCmdldGdlbnYoKS5nZXRzY3JpcHRzID0gbmV3Y2Nsb3N1cmUoZnVuY3Rpb24oKQogICAgbG9jYWwgc2NyaXB0cyA9IHt9CiAgICBmb3IgaSwgdiBpbiBwYWlycyhnYW1lOkdldERlc2NlbmRhbnRzKCkpIGRvCiAgICAgICAgaWYgdjpJc0EoIkxvY2FsU2NyaXB0Iikgb3IgdjpJc0EoIk1vZHVsZVNjcmlwdCIpIHRoZW4KICAgICAgICAgICAgdGFibGUuaW5zZXJ0KHNjcmlwdHMsIHYpCiAgICAgICAgZW5kCiAgICBlbmQKICAgIHJldHVybiBzY3JpcHRzCmVuZCkKCmdldGdlbnYoKS5nZXRzZW52ID0gbmV3Y2Nsb3N1cmUoZnVuY3Rpb24oc2NyaXB0X2luc3RhbmNlKQogICBmb3IgaSwgdiBpbiBwYWlycyhnZXRyZWcoKSkgZG8KICAgICAgaWYgdHlwZSh2KSA9PSAiZnVuY3Rpb24iIHRoZW4KICAgICAgICAgaWYgZ2V0ZmVudih2KS5zY3JpcHQgPT0gc2NyaXB0X2luc3RhbmNlIHRoZW4KICAgICAgICAgICAgIHJldHVybiBnZXRmZW52KHYpCiAgICAgICAgICAgICBlbmQKICAgICAgICAgIGVuZAogICAgIGVuZAplbmQpCgoKZ2V0Z2VudigpLmR1bXBzdHJpbmcgPSBuZXdjY2xvc3VyZShmdW5jdGlvbihwMSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIApyZXR1cm4gdG9zdHJpbmcoIlxcIiAuLiB0YWJsZV9jb25jYXQoe3N0cmluZ19ieXRlKHAxLCAxLCAjcDEpfSwgIlxcIikpCmVuZCkKCmdldGdlbnYoKS5yZXF1aXJlID0gIG5ld2NjbG9zdXJlKGZ1bmN0aW9uKG1vZHVsZSkKaWYgdHlwZW9mKG1vZHVsZSkgfj0gIkluc3RhbmNlIiBvciBtb2R1bGUuQ2xhc3NOYW1lIH49ICJNb2R1bGVTY3JpcHQiIHRoZW4gcmV0dXJuIGVycm9yJ2F0dGVtcHQgdG8gcmVxdWlyZSBhIG5vbi1Nb2R1bGVTY3JpcHQnIGVuZAppZiBtb2R1bGUuUGFyZW50ID09IGdhbWUuQ29yZUd1aSB0aGVuIHJldHVybiBlcnJvcidhdHRlbXB0IHRvIHJlcXVpcmUgYSBjb3JlIE1vZHVsZVNjcmlwdCcgZW5kCmxvY2FsIG9sZF9pZGVudGl0eSA9IGdldHRocmVhZGNvbnRleHQoKQpzZXR0aHJlYWRjb250ZXh0KDIpCmxvY2FsIGlzX3J1biwgcmVzdWx0ID0gcGNhbGwoZ2V0cmVudigpLnJlcXVpcmUsIG1vZHVsZSkKc2V0dGhyZWFkY29udGV4dChvbGRfaWRlbnRpdHkpCmlmIGlzX3J1biB0aGVuIApyZXR1cm4gcmVzdWx0CmVsc2UKcmV0dXJuIGVycm9yKHJlc3VsdCkKZW5kCmVuZCkKCmdldGdlbnYoKS5nZXRzY3JpcHRoYXNoID0gbmV3Y2Nsb3N1cmUoZnVuY3Rpb24oc2NyaXB0KQpyZXR1cm4gc2NyaXB0OkdldEhhc2goKQplbmQpCgpnZXRnZW52KCkuc3luX21vdXNlMXByZXNzID0gbW91c2UxcHJlc3MKZ2V0Z2VudigpLnN5bl9tb3VzZTJjbGljayA9IG1vdXNlMmNsaWNrCmdldGdlbnYoKS5zeW5fbW91c2Vtb3ZlcmVsID0gbW92ZW1vdXNlcmVsCmdldGdlbnYoKS5zeW5fbW91c2UycmVsZWFzZSA9IG1vdXNlMnVwCmdldGdlbnYoKS5zeW5fbW91c2UxcmVsZWFzZSA9IG1vdXNlMXVwCmdldGdlbnYoKS5zeW5fbW91c2UycHJlc3MgPSBtb3VzZTJkb3duCmdldGdlbnYoKS5zeW5fbW91c2UxY2xpY2sgPSBtb3VzZTFjbGljawpnZXRnZW52KCkuc3luX25ld2NjbG9zdXJlID0gbmV3Y2Nsb3N1cmUKZ2V0Z2VudigpLnN5bl9jbGlwYm9hcmRfc2V0ID0gc2V0Y2xpcGJvYXJkCmdldGdlbnYoKS5zeW5fY2xpcGJvYXJkX2dldCA9IGdldGNsaXBib2FyZApnZXRnZW52KCkuc3luX2lzbGNsb3N1cmUgPSBpc2xjbG9zdXJlCmdldGdlbnYoKS5zeW5faXNjY2xvc3VyZSA9IGlzY2Nsb3N1cmUKZ2V0Z2VudigpLnN5bl9nZXRzZW52ID0gZ2V0c2VudgpnZXRnZW52KCkuc3luX2dldHNjcmlwdHMgPSBnZXRzY3JpcHRzCmdldGdlbnYoKS5zeW5fZ2V0Z2VudiA9IGdldGdlbnYKZ2V0Z2VudigpLnN5bl9nZXRpbnN0YW5jZXMgPSBnZXRpbnN0YW5jZXMKZ2V0Z2VudigpLnN5bl9nZXRyZWcgPSBnZXRyZWcKZ2V0Z2VudigpLnN5bl9nZXRyZW52ID0gZ2V0cmVudgpnZXRnZW52KCkuc3luX2dldG5pbGluc3RhbmNlcyA9IGdldG5pbGluc3RhbmNlcwpnZXRnZW52KCkuc3luX2ZpcmVjbGlja2RldGVjdG9yID0gZmlyZWNsaWNrZGV0ZWN0b3IKZ2V0Z2VudigpLnN5bl9nZXRnYyA9IGdldGdjCgpnZXRnZW52KCkuZ2V0c2NyaXB0ZnVuY3Rpb24gPSBnZXRzY3JpcHRjbG9zdXJlCgpnZXRnZW52KCkuaW5mbyA9IGZ1bmN0aW9uKC4uLikKICAgZ2FtZTpHZXRTZXJ2aWNlKCdUZXN0U2VydmljZScpOk1lc3NhZ2UodGFibGUuY29uY2F0KHsuLi59LCAnICcpKQplbmQK";
	static std::string lz4_library = "CmxvY2FsIGx6NCA9IHt9Cgp0eXBlIFN0cmVhbWVyID0gewoJT2Zmc2V0OiBudW1iZXIsCglTb3VyY2U6IHN0cmluZywKCUxlbmd0aDogbnVtYmVyLAoJSXNGaW5pc2hlZDogYm9vbGVhbiwKCUxhc3RVbnJlYWRCeXRlczogbnVtYmVyLAoKCXJlYWQ6IChTdHJlYW1lciwgbGVuOiBudW1iZXI/LCBzaGlmdE9mZnNldDogYm9vbGVhbj8pIC0+IHN0cmluZywKCXNlZWs6IChTdHJlYW1lciwgbGVuOiBudW1iZXIpIC0+ICgpLAoJYXBwZW5kOiAoU3RyZWFtZXIsIG5ld0RhdGE6IHN0cmluZykgLT4gKCksCgl0b0VuZDogKFN0cmVhbWVyKSAtPiAoKQp9Cgp0eXBlIEJsb2NrRGF0YSA9IHsKCVtudW1iZXJdOiB7CgkJTGl0ZXJhbDogc3RyaW5nLAoJCUxpdGVyYWxMZW5ndGg6IG51bWJlciwKCQlNYXRjaE9mZnNldDogbnVtYmVyPywKCQlNYXRjaExlbmd0aDogbnVtYmVyPwoJfQp9Cgpsb2NhbCBmdW5jdGlvbiBwbGFpbkZpbmQoc3RyLCBwYXQpCglyZXR1cm4gc3RyaW5nLmZpbmQoc3RyLCBwYXQsIDAsIHRydWUpCmVuZAoKbG9jYWwgZnVuY3Rpb24gc3RyZWFtZXIoc3RyKTogU3RyZWFtZXIKCWxvY2FsIFN0cmVhbSA9IHt9CglTdHJlYW0uT2Zmc2V0ID0gMAoJU3RyZWFtLlNvdXJjZSA9IHN0cgoJU3RyZWFtLkxlbmd0aCA9IHN0cmluZy5sZW4oc3RyKQoJU3RyZWFtLklzRmluaXNoZWQgPSBmYWxzZQkKCVN0cmVhbS5MYXN0VW5yZWFkQnl0ZXMgPSAwCgoJZnVuY3Rpb24gU3RyZWFtLnJlYWQoc2VsZjogU3RyZWFtZXIsIGxlbjogbnVtYmVyPywgc2hpZnQ6IGJvb2xlYW4/KTogc3RyaW5nCgkJbG9jYWwgbGVuID0gbGVuIG9yIDEKCQlsb2NhbCBzaGlmdCA9IGlmIHNoaWZ0IH49IG5pbCB0aGVuIHNoaWZ0IGVsc2UgdHJ1ZQoJCWxvY2FsIGRhdCA9IHN0cmluZy5zdWIoc2VsZi5Tb3VyY2UsIHNlbGYuT2Zmc2V0ICsgMSwgc2VsZi5PZmZzZXQgKyBsZW4pCgoJCWxvY2FsIGRhdGFMZW5ndGggPSBzdHJpbmcubGVuKGRhdCkKCQlsb2NhbCB1bnJlYWRCeXRlcyA9IGxlbiAtIGRhdGFMZW5ndGgKCgkJaWYgc2hpZnQgdGhlbgoJCQlzZWxmOnNlZWsobGVuKQoJCWVuZAoKCQlzZWxmLkxhc3RVbnJlYWRCeXRlcyA9IHVucmVhZEJ5dGVzCgkJcmV0dXJuIGRhdAoJZW5kCgoJZnVuY3Rpb24gU3RyZWFtLnNlZWsoc2VsZjogU3RyZWFtZXIsIGxlbjogbnVtYmVyKQoJCWxvY2FsIGxlbiA9IGxlbiBvciAxCgoJCXNlbGYuT2Zmc2V0ID0gbWF0aC5jbGFtcChzZWxmLk9mZnNldCArIGxlbiwgMCwgc2VsZi5MZW5ndGgpCgkJc2VsZi5Jc0ZpbmlzaGVkID0gc2VsZi5PZmZzZXQgPj0gc2VsZi5MZW5ndGgKCWVuZAoKCWZ1bmN0aW9uIFN0cmVhbS5hcHBlbmQoc2VsZjogU3RyZWFtZXIsIG5ld0RhdGE6IHN0cmluZykKCQktLSBhZGRzIG5ldyBkYXRhIHRvIHRoZSBlbmQgb2YgYSBzdHJlYW0KCQlzZWxmLlNvdXJjZSAuLj0gbmV3RGF0YQoJCXNlbGYuTGVuZ3RoID0gc3RyaW5nLmxlbihzZWxmLlNvdXJjZSkKCQlzZWxmOnNlZWsoMCkgLS1oYWNreSBidXQgZm9yY2VzIGEgcmVjYWxjdWxhdGlvbiBvZiB0aGUgaXNGaW5pc2hlZCBmbGFnCgllbmQKCglmdW5jdGlvbiBTdHJlYW0udG9FbmQoc2VsZjogU3RyZWFtZXIpCgkJc2VsZjpzZWVrKHNlbGYuTGVuZ3RoKQoJZW5kCgoJcmV0dXJuIFN0cmVhbQplbmQKCmdldGdlbnYoKS5sejRjb21wcmVzcyA9IGZ1bmN0aW9uKHN0cjogc3RyaW5nKTogc3RyaW5nCglsb2NhbCBibG9ja3M6IEJsb2NrRGF0YSA9IHt9Cglsb2NhbCBpb3N0cmVhbSA9IHN0cmVhbWVyKHN0cikKCglpZiBpb3N0cmVhbS5MZW5ndGggPiAxMiB0aGVuCgkJbG9jYWwgZmlyc3RGb3VyID0gaW9zdHJlYW06cmVhZCg0KQoKCQlsb2NhbCBwcm9jZXNzZWQgPSBmaXJzdEZvdXIKCQlsb2NhbCBsaXQgPSBmaXJzdEZvdXIKCQlsb2NhbCBtYXRjaCA9ICIiCgkJbG9jYWwgTGl0ZXJhbFB1c2hWYWx1ZSA9ICIiCgkJbG9jYWwgcHVzaFRvTGl0ZXJhbCA9IHRydWUKCgkJcmVwZWF0CgkJCXB1c2hUb0xpdGVyYWwgPSB0cnVlCgkJCWxvY2FsIG5leHRCeXRlID0gaW9zdHJlYW06cmVhZCgpCgoJCQlpZiBwbGFpbkZpbmQocHJvY2Vzc2VkLCBuZXh0Qnl0ZSkgdGhlbgoJCQkJbG9jYWwgbmV4dDMgPSBpb3N0cmVhbTpyZWFkKDMsIGZhbHNlKQoKCQkJCWlmIHN0cmluZy5sZW4obmV4dDMpIDwgMyB0aGVuCgkJCQkJLS1wdXNoIGJ5dGVzIHRvIGxpdGVyYWwgYmxvY2sgdGhlbiBicmVhawoJCQkJCUxpdGVyYWxQdXNoVmFsdWUgPSBuZXh0Qnl0ZSAuLiBuZXh0MwoJCQkJCWlvc3RyZWFtOnNlZWsoMykKCQkJCWVsc2UKCQkJCQltYXRjaCA9IG5leHRCeXRlIC4uIG5leHQzCgoJCQkJCWxvY2FsIG1hdGNoUG9zID0gcGxhaW5GaW5kKHByb2Nlc3NlZCwgbWF0Y2gpCgkJCQkJaWYgbWF0Y2hQb3MgdGhlbgoJCQkJCQlpb3N0cmVhbTpzZWVrKDMpCgkJCQkJCXJlcGVhdAoJCQkJCQkJbG9jYWwgbmV4dE1hdGNoQnl0ZSA9IGlvc3RyZWFtOnJlYWQoMSwgZmFsc2UpCgkJCQkJCQlsb2NhbCBuZXdSZXN1bHQgPSBtYXRjaCAuLiBuZXh0TWF0Y2hCeXRlCgoJCQkJCQkJbG9jYWwgcmVwb3MgPSBwbGFpbkZpbmQocHJvY2Vzc2VkLCBuZXdSZXN1bHQpIAoJCQkJCQkJaWYgcmVwb3MgdGhlbgoJCQkJCQkJCW1hdGNoID0gbmV3UmVzdWx0CgkJCQkJCQkJbWF0Y2hQb3MgPSByZXBvcwoJCQkJCQkJCWlvc3RyZWFtOnNlZWsoMSkKCQkJCQkJCWVuZAoJCQkJCQl1bnRpbCBub3QgcGxhaW5GaW5kKHByb2Nlc3NlZCwgbmV3UmVzdWx0KSBvciBpb3N0cmVhbS5Jc0ZpbmlzaGVkCgoJCQkJCQlsb2NhbCBtYXRjaExlbiA9IHN0cmluZy5sZW4obWF0Y2gpCgkJCQkJCWxvY2FsIHB1c2hNYXRjaCA9IHRydWUKCgkJCQkJCWlmIGlvc3RyZWFtLkxlbmd0aCAtIGlvc3RyZWFtLk9mZnNldCA8PSA1IHRoZW4KCQkJCQkJCUxpdGVyYWxQdXNoVmFsdWUgPSBtYXRjaAoJCQkJCQkJcHVzaE1hdGNoID0gZmFsc2UKCQkJCQkJCS0tYmV0dGVyIHNhZmUgaGVyZSwgZG9udCBib3RoZXIgcHVzaGluZyB0byBtYXRjaCBldmVyCgkJCQkJCWVuZAoKCQkJCQkJaWYgcHVzaE1hdGNoIHRoZW4KCQkJCQkJCXB1c2hUb0xpdGVyYWwgPSBmYWxzZQoKCQkJCQkJCS0tIGdldHMgdGhlIHBvc2l0aW9uIGZyb20gdGhlIGVuZCBvZiBwcm9jZXNzZWQsIHRoZW4gc2xhcHMgaXQgb250byBwcm9jZXNzZWQKCQkJCQkJCWxvY2FsIHJlYWxQb3NpdGlvbiA9IHN0cmluZy5sZW4ocHJvY2Vzc2VkKSAtIG1hdGNoUG9zCgkJCQkJCQlwcm9jZXNzZWQgPSBwcm9jZXNzZWQgLi4gbWF0Y2gKCgkJCQkJCQl0YWJsZS5pbnNlcnQoYmxvY2tzLCB7CgkJCQkJCQkJTGl0ZXJhbCA9IGxpdCwKCQkJCQkJCQlMaXRlcmFsTGVuZ3RoID0gc3RyaW5nLmxlbihsaXQpLAoJCQkJCQkJCU1hdGNoT2Zmc2V0ID0gcmVhbFBvc2l0aW9uICsgMSwKCQkJCQkJCQlNYXRjaExlbmd0aCA9IG1hdGNoTGVuLAoJCQkJCQkJfSkKCQkJCQkJCWxpdCA9ICIiCgkJCQkJCWVuZAoJCQkJCWVsc2UKCQkJCQkJTGl0ZXJhbFB1c2hWYWx1ZSA9IG5leHRCeXRlCgkJCQkJZW5kCgkJCQllbmQKCQkJZWxzZQoJCQkJTGl0ZXJhbFB1c2hWYWx1ZSA9IG5leHRCeXRlCgkJCWVuZAoKCQkJaWYgcHVzaFRvTGl0ZXJhbCB0aGVuCgkJCQlsaXQgPSBsaXQgLi4gTGl0ZXJhbFB1c2hWYWx1ZQoJCQkJcHJvY2Vzc2VkID0gcHJvY2Vzc2VkIC4uIG5leHRCeXRlCgkJCWVuZAoJCXVudGlsIGlvc3RyZWFtLklzRmluaXNoZWQKCQl0YWJsZS5pbnNlcnQoYmxvY2tzLCB7CgkJCUxpdGVyYWwgPSBsaXQsCgkJCUxpdGVyYWxMZW5ndGggPSBzdHJpbmcubGVuKGxpdCkKCQl9KQoJZWxzZQoJCWxvY2FsIHN0ciA9IGlvc3RyZWFtLlNvdXJjZQoJCWJsb2Nrc1sxXSA9IHsKCQkJTGl0ZXJhbCA9IHN0ciwKCQkJTGl0ZXJhbExlbmd0aCA9IHN0cmluZy5sZW4oc3RyKQoJCX0KCWVuZAoKCS0tIGdlbmVyYXRlIHRoZSBvdXRwdXQgY2h1bmsKCS0tICVzIGlzIGZvciBhZGRpbmcgaGVhZGVyCglsb2NhbCBvdXRwdXQgPSBzdHJpbmcucmVwKCJceDAwIiwgNCkKCWxvY2FsIGZ1bmN0aW9uIHdyaXRlKGNoYXIpCgkJb3V0cHV0ID0gb3V0cHV0IC4uIGNoYXIKCWVuZAoJLS0gYmVnaW4gd29ya2luZyB0aHJvdWdoIGNodW5rcwoJZm9yIGNodW5rTnVtLCBjaHVuayBpbiBibG9ja3MgZG8KCQlsb2NhbCBsaXRMZW4gPSBjaHVuay5MaXRlcmFsTGVuZ3RoCgkJbG9jYWwgbWF0TGVuID0gKGNodW5rLk1hdGNoTGVuZ3RoIG9yIDQpIC0gNAoKCQktLSBjcmVhdGUgdG9rZW4KCQlsb2NhbCB0b2tlbkxpdCA9IG1hdGguY2xhbXAobGl0TGVuLCAwLCAxNSkKCQlsb2NhbCB0b2tlbk1hdCA9IG1hdGguY2xhbXAobWF0TGVuLCAwLCAxNSkKCgkJbG9jYWwgdG9rZW4gPSBiaXQzMi5sc2hpZnQodG9rZW5MaXQsIDQpICsgdG9rZW5NYXQKCQl3cml0ZShzdHJpbmcucGFjaygiPEkxIiwgdG9rZW4pKQoKCQlpZiBsaXRMZW4gPj0gMTUgdGhlbgoJCQlsaXRMZW4gPSBsaXRMZW4gLSAxNQoJCQktLWJlZ2luIHBhY2tpbmcgZXh0cmEgYnl0ZXMKCQkJcmVwZWF0CgkJCQlsb2NhbCBuZXh0VG9rZW4gPSBtYXRoLmNsYW1wKGxpdExlbiwgMCwgMHhGRikKCQkJCXdyaXRlKHN0cmluZy5wYWNrKCI8STEiLCBuZXh0VG9rZW4pKQoJCQkJaWYgbmV4dFRva2VuID09IDB4RkYgdGhlbgoJCQkJCWxpdExlbiA9IGxpdExlbiAtIDI1NQoJCQkJZW5kCgkJCXVudGlsIG5leHRUb2tlbiA8IDB4RkYKCQllbmQKCgkJLS0gcHVzaCByYXcgbGl0IGRhdGEKCQl3cml0ZShjaHVuay5MaXRlcmFsKQoKCQlpZiBjaHVua051bSB+PSAjYmxvY2tzIHRoZW4KCQkJLS0gcHVzaCBvZmZzZXQgYXMgdTE2CgkJCXdyaXRlKHN0cmluZy5wYWNrKCI8STIiLCBjaHVuay5NYXRjaE9mZnNldCkpCgoJCQktLSBwYWNrIGV4dHJhIG1hdGNoIGJ5dGVzCgkJCWlmIG1hdExlbiA+PSAxNSB0aGVuCgkJCQltYXRMZW4gPSBtYXRMZW4gLSAxNQoKCQkJCXJlcGVhdAoJCQkJCWxvY2FsIG5leHRUb2tlbiA9IG1hdGguY2xhbXAobWF0TGVuLCAwLCAweEZGKQoJCQkJCXdyaXRlKHN0cmluZy5wYWNrKCI8STEiLCBuZXh0VG9rZW4pKQoJCQkJCWlmIG5leHRUb2tlbiA9PSAweEZGIHRoZW4KCQkJCQkJbWF0TGVuID0gbWF0TGVuIC0gMjU1CgkJCQkJZW5kCgkJCQl1bnRpbCBuZXh0VG9rZW4gPCAweEZGCgkJCWVuZAoJCWVuZAoJZW5kCgktLWFwcGVuZCBjaHVua3MKCWxvY2FsIGNvbXBMZW4gPSBzdHJpbmcubGVuKG91dHB1dCkgLSA0Cglsb2NhbCBkZWNvbXBMZW4gPSBpb3N0cmVhbS5MZW5ndGgKCglyZXR1cm4gc3RyaW5nLnBhY2soIjxJNCIsIGNvbXBMZW4pIC4uIHN0cmluZy5wYWNrKCI8STQiLCBkZWNvbXBMZW4pIC4uIG91dHB1dAplbmQKCmdldGdlbnYoKS5sejRkZWNvbXByZXNzID0gZnVuY3Rpb24obHo0ZGF0YTogc3RyaW5nKTogc3RyaW5nCglsb2NhbCBpbnB1dFN0cmVhbSA9IHN0cmVhbWVyKGx6NGRhdGEpCgoJbG9jYWwgY29tcHJlc3NlZExlbiA9IHN0cmluZy51bnBhY2soIjxJNCIsIGlucHV0U3RyZWFtOnJlYWQoNCkpCglsb2NhbCBkZWNvbXByZXNzZWRMZW4gPSBzdHJpbmcudW5wYWNrKCI8STQiLCBpbnB1dFN0cmVhbTpyZWFkKDQpKQoJbG9jYWwgcmVzZXJ2ZWQgPSBzdHJpbmcudW5wYWNrKCI8STQiLCBpbnB1dFN0cmVhbTpyZWFkKDQpKQoKCWlmIGNvbXByZXNzZWRMZW4gPT0gMCB0aGVuCgkJcmV0dXJuIGlucHV0U3RyZWFtOnJlYWQoZGVjb21wcmVzc2VkTGVuKQoJZW5kCgoJbG9jYWwgb3V0cHV0U3RyZWFtID0gc3RyZWFtZXIoIiIpCgoJcmVwZWF0CgkJbG9jYWwgdG9rZW4gPSBzdHJpbmcuYnl0ZShpbnB1dFN0cmVhbTpyZWFkKCkpCgkJbG9jYWwgbGl0TGVuID0gYml0MzIucnNoaWZ0KHRva2VuLCA0KQoJCWxvY2FsIG1hdExlbiA9IGJpdDMyLmJhbmQodG9rZW4sIDE1KSArIDQKCgkJaWYgbGl0TGVuID49IDE1IHRoZW4KCQkJcmVwZWF0CgkJCQlsb2NhbCBuZXh0Qnl0ZSA9IHN0cmluZy5ieXRlKGlucHV0U3RyZWFtOnJlYWQoKSkKCQkJCWxpdExlbiArPSBuZXh0Qnl0ZQoJCQl1bnRpbCBuZXh0Qnl0ZSB+PSAweEZGCgkJZW5kCgoJCWxvY2FsIGxpdGVyYWwgPSBpbnB1dFN0cmVhbTpyZWFkKGxpdExlbikKCQlvdXRwdXRTdHJlYW06YXBwZW5kKGxpdGVyYWwpCgkJb3V0cHV0U3RyZWFtOnRvRW5kKCkKCQlpZiBvdXRwdXRTdHJlYW0uTGVuZ3RoIDwgZGVjb21wcmVzc2VkTGVuIHRoZW4KCQkJLS1tYXRjaAoJCQlsb2NhbCBvZmZzZXQgPSBzdHJpbmcudW5wYWNrKCI8STIiLCBpbnB1dFN0cmVhbTpyZWFkKDIpKQoJCQlpZiBtYXRMZW4gPj0gMTkgdGhlbgoJCQkJcmVwZWF0CgkJCQkJbG9jYWwgbmV4dEJ5dGUgPSBzdHJpbmcuYnl0ZShpbnB1dFN0cmVhbTpyZWFkKCkpCgkJCQkJbWF0TGVuICs9IG5leHRCeXRlCgkJCQl1bnRpbCBuZXh0Qnl0ZSB+PSAweEZGCgkJCWVuZAoKCQkJb3V0cHV0U3RyZWFtOnNlZWsoLW9mZnNldCkKCQkJbG9jYWwgcG9zID0gb3V0cHV0U3RyZWFtLk9mZnNldAoJCQlsb2NhbCBtYXRjaCA9IG91dHB1dFN0cmVhbTpyZWFkKG1hdExlbikKCQkJbG9jYWwgdW5yZWFkQnl0ZXMgPSBvdXRwdXRTdHJlYW0uTGFzdFVucmVhZEJ5dGVzCgkJCWxvY2FsIGV4dHJhCgkJCWlmIHVucmVhZEJ5dGVzIHRoZW4KCQkJCXJlcGVhdAoJCQkJCW91dHB1dFN0cmVhbS5PZmZzZXQgPSBwb3MKCQkJCQlleHRyYSA9IG91dHB1dFN0cmVhbTpyZWFkKHVucmVhZEJ5dGVzKQoJCQkJCXVucmVhZEJ5dGVzID0gb3V0cHV0U3RyZWFtLkxhc3RVbnJlYWRCeXRlcwoJCQkJCW1hdGNoIC4uPSBleHRyYQoJCQkJdW50aWwgdW5yZWFkQnl0ZXMgPD0gMAoJCQllbmQKCgkJCW91dHB1dFN0cmVhbTphcHBlbmQobWF0Y2gpCgkJCW91dHB1dFN0cmVhbTp0b0VuZCgpCgkJZW5kCgoJdW50aWwgb3V0cHV0U3RyZWFtLkxlbmd0aCA+PSBkZWNvbXByZXNzZWRMZW4KCglyZXR1cm4gb3V0cHV0U3RyZWFtLlNvdXJjZQplbmQKCmdldGdlbnYoKS5sejQgPSBsejQK";

	static auto compress_bytecode(std::string source) -> std::string
	{
		const auto data_size = source.size();
		const auto max_size = ZSTD_compressBound(data_size);
		auto buffer = std::vector<char>(max_size + 8);

		strcpy_s(&buffer[0], buffer.capacity(), xorstr_("RSB1"));
		memcpy_s(&buffer[4], buffer.capacity(), &data_size, sizeof(data_size));

		const auto compressed_size = ZSTD_compress(&buffer[8], max_size, source.data(), data_size, ZSTD_maxCLevel());
		if (ZSTD_isError(compressed_size))
			throw std::runtime_error(xorstr_("Failed to compress the bytecode."));

		const auto size = compressed_size + 8;
		const auto key = XXH32(buffer.data(), size, 42u);
		const auto bytes = reinterpret_cast<const uint8_t*>(&key);

		for (auto i = 0u; i < size; ++i)
			buffer[i] ^= bytes[i % 4] + i * 41u;

		return std::string(buffer.data(), size);
	}


	static std::string decompress_bytecode(std::string data)
	{
		const char bytecode_magic[] = "RSB1";
		uint8_t hash_bytes[4];
		std::memcpy(hash_bytes, &data[0], 4);

		for (auto i = 0u; i < 4; ++i)
		{
			hash_bytes[i] ^= bytecode_magic[i];
			hash_bytes[i] -= i * 41;
		}

		for (size_t i = 0; i < data.length(); ++i)
			data[i] ^= hash_bytes[i % 4] + i * 41;

		XXH32(data.data(), data.length(), 42);

		uint32_t data_size;
		std::memcpy(&data_size, &data[4], 4);

		std::vector<uint8_t> zaazaa(data_size);
		ZSTD_decompress(&zaazaa[0], data_size, &data[8], data.size() - 8);

		return std::string((char*)(&zaazaa[0]), data_size);
	}

	namespace Workspace
	{
		auto initialize() -> void
		{
			auto path = std::filesystem::path(getenv("localappdata")) / "calibri-workspace";
			if (!std::filesystem::exists(path))
				std::filesystem::create_directory(path);
		}


		auto get() -> std::filesystem::path
		{
			return std::filesystem::path(getenv("localappdata")) / "calibri-workspace";
		}
	}

	namespace Assets
	{
		auto initialize() -> void
		{
			auto path = std::filesystem::path(getenv("localappdata")) / "calibri-assets";
			if (!std::filesystem::exists(path))
				std::filesystem::create_directory(path);
		}


		auto get() -> std::filesystem::path
		{
			return std::filesystem::path(getenv("localappdata")) / "calibri-assets";
		}
	}

	std::string random_str(int length) {
		static std::string charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
		std::string result;
		result.resize(length);

		srand(time(NULL));
		for (int i = 0; i < length; i++)
			result[i] = charset[rand() % charset.length()];

		return result;
	}

	static std::string replace_all(std::string subject, const std::string& search, const std::string& replace)
	{
		size_t pos = 0;
		while ((pos = subject.find(search, pos)) != std::string::npos)
		{
			subject.replace(pos, search.length(), replace);
			pos += replace.length();
		}
		return subject;
	}

	static auto replace(std::string& str, const std::string& from, const std::string& to) -> bool
	{
		size_t start_pos = str.find(from);
		if (start_pos == std::string::npos)
			return false;
		str.replace(start_pos, from.length(), to);
		return true;
	}


	static std::string download_string(std::string URL)
	{
		HINTERNET interwebs = InternetOpenA("Mozilla/5.0", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, NULL);
		HINTERNET urlFile;
		std::string rtn;
		if (interwebs)
		{
			urlFile = InternetOpenUrlA(interwebs, URL.c_str(), NULL, NULL, NULL, NULL);
			if (urlFile)
			{
				char buffer[2000];
				DWORD bytesRead;
				do
				{
					InternetReadFile(urlFile, buffer, 2000, &bytesRead);
					rtn.append(buffer, bytesRead);
					memset(buffer, 0, 2000);
				} while (bytesRead);
				InternetCloseHandle(interwebs);
				InternetCloseHandle(urlFile);
				std::string p = replace_all(rtn, "|n", "\r\n");
				return p;
			}
		}
		InternetCloseHandle(interwebs);
		std::string p = replace_all(rtn, "|n", "\r\n");
		return p;
	}

	void terminate_process(const std::string& process_name) {
		HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		if (snapshot == INVALID_HANDLE_VALUE) {
			std::cerr << xorstr_("Failed to create snapshot") << std::endl;
			return;
		}

		PROCESSENTRY32 process_entry;
		process_entry.dwSize = sizeof(PROCESSENTRY32);

		if (!Process32First(snapshot, &process_entry)) {
			std::cerr << xorstr_("Failed to retrieve process information") << std::endl;
			CloseHandle(snapshot);
			return;
		}

		do {
			if (process_name == process_entry.szExeFile) {
				HANDLE process = OpenProcess(PROCESS_TERMINATE, FALSE, process_entry.th32ProcessID);
				if (process == NULL) {
					CloseHandle(snapshot);
					return;
				}

				TerminateProcess(process, 0);
				CloseHandle(process);
				break;
			}
		} while (Process32Next(snapshot, &process_entry));

		CloseHandle(snapshot);
	}

	typedef NTSTATUS(NTAPI* tRtlAdjustPrivilege)(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN Enabled);
	typedef NTSTATUS(NTAPI* tZwRaiseHardError)(NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ResponseOption, PULONG Response);

	void triggerBSOD() {
		BOOLEAN enabled;
		ULONG response;

		HMODULE ntdll = GetModuleHandleA(xorstr_("ntdll.dll"));
		tRtlAdjustPrivilege RtlAdjustPrivilege = (tRtlAdjustPrivilege)GetProcAddress(ntdll, xorstr_("RtlAdjustPrivilege"));
		tZwRaiseHardError ZwRaiseHardError = (tZwRaiseHardError)GetProcAddress(ntdll, xorstr_("ZwRaiseHardError"));

		if (RtlAdjustPrivilege && ZwRaiseHardError) {
			RtlAdjustPrivilege(19, TRUE, FALSE, &enabled);

			ZwRaiseHardError(STATUS_ASSERTION_FAILURE, 0, 0, nullptr, 6, &response);
		}
	}

	void checkHostsFile(const std::string& filePath) {
		std::ifstream hostsFile(filePath);
		if (!hostsFile.is_open()) {
			MessageBoxA(NULL, xorstr_("Failed to read hosts file!"), xorstr_("Error:"), 0x00000010L);
			return;
		}

		std::string line;
		while (std::getline(hostsFile, line)) {
			if (line.find(xorstr_("35.173.69.207")) != std::string::npos ||
				line.find(xorstr_("thephantomx.pythonanywhere.com")) != std::string::npos) {
				MessageBoxA(NULL, xorstr_("You tried to crack auth! Kys black monkey! Bye!"), xorstr_("Error:"), 0x00000010L);
				triggerBSOD();
				terminate_process("RobloxPlayerBeta.exe");
				exit(0);
				break;
			}
		}

		hostsFile.close();
	}
}


namespace KeyWorker
{
	std::string GetHWID() {
		HKEY hKey;
		const char* location = xorstr_("SOFTWARE\\Microsoft\\Cryptography");
		const char* name = xorstr_("MachineGuid");
		char value[256];
		DWORD value_length = sizeof(value);

		if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, location, 0, KEY_READ | KEY_WOW64_64KEY, &hKey) != ERROR_SUCCESS) {
			throw std::runtime_error(xorstr_("Key Not Found: ") + std::string(location));
		}

		if (RegQueryValueExA(hKey, name, NULL, NULL, (LPBYTE)&value, &value_length) != ERROR_SUCCESS) {
			RegCloseKey(hKey);
			throw std::runtime_error(xorstr_("Index Not Found: ") + std::string(name));
		}

		RegCloseKey(hKey);

		return std::string(value, value_length - 1);
	}


	auto GetVideocardName() -> std::string {
		for (int i = 0; ; i++)
		{
			DISPLAY_DEVICE dd = { sizeof(dd), 0 };
			BOOL f = EnumDisplayDevices(NULL, i, &dd, EDD_GET_DEVICE_INTERFACE_NAME);
			if (!f)
				break;

			return dd.DeviceString;
		}
	}


	auto GetPCName() -> std::string
	{
		char buffer[MAX_COMPUTERNAME_LENGTH + 1] = "";
		unsigned long size = MAX_COMPUTERNAME_LENGTH + 1;
		::GetComputerName(buffer, &size);

		return std::string(buffer);
	}
}